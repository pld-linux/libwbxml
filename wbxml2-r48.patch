Index: /wbxml2/trunk/src/wbxml_parser.c
===================================================================
--- /wbxml2/trunk/src/wbxml_parser.c (revision 44)
+++ /wbxml2/trunk/src/wbxml_parser.c (revision 48)
@@ -154,4 +154,6 @@
 
 /* Language Specific Decoding Functions */
+static WBXMLError decode_base64_value(WBXMLBuffer **data);
+
 #if defined( WBXML_SUPPORT_SI ) || defined( WBXML_SUPPORT_EMN )
 static WBXMLError decode_datetime(WBXMLBuffer *buff);
@@ -159,4 +161,5 @@
 
 static WBXMLError decode_opaque_content(WBXMLParser *parser, WBXMLBuffer **data);
+static WBXMLError decode_opaque_attr_value(WBXMLParser *parser, WBXMLBuffer **data);
 
 #if defined( WBXML_SUPPORT_WV )
@@ -165,8 +168,4 @@
 static WBXMLError decode_wv_datetime(WBXMLBuffer **data);
 #endif /* WBXML_SUPPORT_WV */
-
-#if defined( WBXML_SUPPORT_DRMREL )
-static WBXMLError decode_drmrel_keyvalue(WBXMLBuffer **data);
-#endif /* WBXML_SUPPORT_DRMREL */
 
 /* Macro for error handling */
@@ -1953,5 +1952,8 @@
         }
         
-        return parse_opaque(parser, result);
+        if ((ret = parse_opaque(parser, result)) != WBXML_OK) 
+            return ret;
+        
+        return decode_opaque_attr_value(parser, result);
     }
   
@@ -2215,4 +2217,38 @@
  * Language Specific Decoding Functions 
  */
+
+/**
+ * @brief Decode a BASE64 value
+ * @param data [in/out]The value to decode
+ * @return WBXML_OK if OK, another error code otherwise
+ */
+static WBXMLError decode_base64_value(WBXMLBuffer **data)
+{
+    WB_UTINY   *result = NULL;
+    WBXMLError  ret    = WBXML_OK;
+    
+    if ((data == NULL) || (*data == NULL)) {
+        return WBXML_ERROR_INTERNAL;
+    }
+    
+    if ((result = wbxml_base64_encode((const WB_UTINY *) wbxml_buffer_get_cstr(*data),
+                                      wbxml_buffer_len(*data))) == NULL)
+    {
+        return WBXML_ERROR_B64_ENC;
+    }
+    
+    /* Reset buffer */
+    wbxml_buffer_delete(*data, 0, wbxml_buffer_len(*data));
+    
+    /* Set data */
+    if (!wbxml_buffer_append_cstr(*data, result)) {
+        ret = WBXML_ERROR_NOT_ENOUGH_MEMORY;
+    }
+    
+    wbxml_free(result);
+    
+    return ret;
+}
+
 
 #if ( defined( WBXML_SUPPORT_SI ) || defined( WBXML_SUPPORT_EMN ) )
@@ -2304,6 +2340,4 @@
  * @param data The Opaque data buffer
  * @return WBXML_OK if OK, another error code otherwise
- * @note Used for:
- *      - WV 1.1 / 1.2
  */
 static WBXMLError decode_opaque_content(WBXMLParser  *parser,
@@ -2325,4 +2359,5 @@
 
     case WBXML_LANG_DRMREL10:
+        /* ds:KeyValue */
         if ((parser->current_tag->wbxmlCodePage == 0x00) &&
             (parser->current_tag->wbxmlToken == 0x0C))
@@ -2330,6 +2365,6 @@
             WBXMLError ret = WBXML_OK;
             
-            /* Decode <KeyValue> */
-            if ((ret = decode_drmrel_keyvalue(data)) != WBXML_OK)
+            /* Decode base64 value */ 
+            if ((ret = decode_base64_value(data)) != WBXML_OK)
                 return ret;
 
@@ -2339,5 +2374,60 @@
 
 #endif /* WBXML_SUPPORT_DRMREL */    
-    
+
+#if defined( WBXML_SUPPORT_SYNCML )
+
+    case WBXML_LANG_SYNCML_SYNCML10: 
+    case WBXML_LANG_SYNCML_SYNCML11: 
+    case WBXML_LANG_SYNCML_SYNCML12: 
+        /* NextNonce */
+        if ((parser->current_tag->wbxmlCodePage == 0x01) &&
+            (parser->current_tag->wbxmlToken == 0x10)) 
+        {
+            WBXMLError ret = WBXML_OK;
+            
+            /* Decode base64 value */ 
+            if ((ret = decode_base64_value(data)) != WBXML_OK)
+                return ret;
+                
+            return WBXML_OK;
+        }
+        break;
+
+#endif /* WBXML_SUPPORT_SYNCML */    
+
+    default:
+        /* NOP */
+        break;
+    } /* switch */
+  
+    return WBXML_OK;
+}
+
+
+/**
+ * @brief Decode an Opaque Attribute Value buffer
+ * @param parser The WBXML Parser
+ * @param data The Opaque data buffer
+ * @return WBXML_OK if OK, another error code otherwise
+ */
+static WBXMLError decode_opaque_attr_value(WBXMLParser *parser, WBXMLBuffer **data)
+{
+    switch (parser->langTable->langID) 
+    {
+#if defined( WBXML_SUPPORT_OTA_SETTINGS )
+
+    case WBXML_LANG_OTA_SETTINGS:
+    {
+        WBXMLError ret = WBXML_OK;
+        
+        /* Decode base64 value */
+        if ((ret = decode_base64_value(data)) != WBXML_OK)
+            return ret; 
+
+        return WBXML_OK;
+    }
+
+#endif /* WBXML_SUPPORT_OTA_SETTINGS */ 
+
     default:
         /* NOP */
@@ -2712,48 +2802,2 @@
 
 #endif /* WBXML_SUPPORT_WV */
-
-
-#if defined( WBXML_SUPPORT_DRMREL )
-
-/**************************************
- * DRMREL 1.0
- */
-
-/**
- * @brief Decode a DRMREL 'KeyValue'
- * @param data The KeyValue to decode
- * @return WBXML_OK if OK, another error code otherwise
- * @note Used for:
- *      - DRMREL 1.0
- * @note [OMA-Download-DRMREL-v1_0-20020913-C.PDF] - 7.1:
- *       "The content of the <KeyValue> element MUST be in binary format using the opaque token."
- */
-static WBXMLError decode_drmrel_keyvalue(WBXMLBuffer **data)
-{
-    WB_UTINY   *result = NULL;
-    WBXMLError  ret    = WBXML_OK;
-  
-    if ((data == NULL) || (*data == NULL)) {
-        return WBXML_ERROR_INTERNAL;
-    }
-  
-    if ((result = wbxml_base64_encode((const WB_UTINY *) wbxml_buffer_get_cstr(*data),
-                                      wbxml_buffer_len(*data))) == NULL)
-    {
-        return WBXML_ERROR_B64_ENC;
-    }
-
-    /* Reset buffer */
-    wbxml_buffer_delete(*data, 0, wbxml_buffer_len(*data));
-
-    /* Set data */
-    if (!wbxml_buffer_append_cstr(*data, result)) {
-        ret = WBXML_ERROR_NOT_ENOUGH_MEMORY;
-    }
-
-    wbxml_free(result);
-  
-    return ret;
-}
-
-#endif /* WBXML_SUPPORT_DRMREL */
Index: /wbxml2/trunk/src/wbxml_encoder.c
===================================================================
--- /wbxml2/trunk/src/wbxml_encoder.c (revision 42)
+++ /wbxml2/trunk/src/wbxml_encoder.c (revision 48)
@@ -128,4 +128,8 @@
  * @warning For now 'current_text_parent' field is only used for DRM REL Content Encoding. It should not be
  *          used for another purpose.
+ *
+ * @warning For now 'current_node' field is a hack. It is reset after End Tag, and as there is no Linked List
+ *          mecanism, this is bad for cascading elements: we don't fill this field with parent Tag
+ *          when parsing End Tag.
  */
 struct WBXMLEncoder_s {
@@ -137,4 +141,5 @@
     const WBXMLTreeNode *current_text_parent; /**< Text parent of current Node (See The Warning For This Field !) */
     const WBXMLAttrEntry *current_attr;     /**< Current Attribute */
+    WBXMLTreeNode *current_node;            /**< Current Node (See The Warning For This Field !) */
     WB_UTINY tagCodePage;                   /**< Current Tag Code Page */
     WB_UTINY attrCodePage;                  /**< Current Attribute Code Page */
@@ -270,4 +275,5 @@
 #endif /* 0 */
 static WBXMLError wbxml_encode_opaque(WBXMLEncoder *encoder, WBXMLBuffer *buff);
+static WBXMLError wbxml_encode_opaque_data(WBXMLEncoder *encoder, WB_UTINY *data, WB_ULONG data_len);
 #if defined( WBXML_ENCODER_USE_STRTBL )
 static WBXMLError wbxml_encode_tableref(WBXMLEncoder *encoder, WB_ULONG offset);
@@ -293,4 +299,8 @@
 static WBXMLError wbxml_encode_drmrel_content(WBXMLEncoder *encoder, WB_UTINY *buffer);
 #endif /* WBXML_SUPPORT_DRMREL */
+
+#if defined( WBXML_SUPPORT_OTA_SETTINGS ) 
+static WBXMLError wbxml_encode_ota_nokia_icon(WBXMLEncoder *encoder, WB_UTINY *buffer);
+#endif /* WBXML_SUPPORT_OTA_SETTINGS */
 
 #if defined( WBXML_ENCODER_USE_STRTBL )
@@ -384,4 +394,5 @@
     encoder->current_text_parent = NULL;
     encoder->current_attr = NULL;
+    encoder->current_node = NULL;
 
     encoder->tagCodePage = 0;
@@ -451,4 +462,5 @@
     encoder->current_tag = NULL;
     encoder->current_attr = NULL;
+    encoder->current_node = NULL;
     
     encoder->tagCodePage = 0;
@@ -966,4 +978,7 @@
 {
     WBXMLError ret = WBXML_OK;
+    
+    /* Set current node */
+    encoder->current_node = node;
 
     /* Parse this node */
@@ -1077,6 +1092,7 @@
     }
 
-    /* Reset Current Tag */
+    /* Reset Current Tag and Current Node */
     encoder->current_tag = NULL;
+    encoder->current_node = NULL;
 
     /* Parse next node */
@@ -1896,4 +1912,20 @@
 #endif /* WBXML_SUPPORT_EMN */
 
+#if defined( WBXML_SUPPORT_OTA_SETTINGS )
+        case WBXML_LANG_OTA_SETTINGS:
+            /**
+             * Nokia OTA Settings support for the ICON value in bookmarks.
+             * The encoding is done using base64 encoded images in XML, and encoding it as OPAQUE data in the WBXML. 
+             * The icon is embedded using an PARM element with name ICON.
+             */
+            if ((encoder->current_attr->wbxmlCodePage == 0x00) &&
+                (encoder->current_attr->wbxmlToken == 0x11)) 
+            {
+                if ((ret = wbxml_encode_ota_nokia_icon(encoder, buffer)) != WBXML_NOT_ENCODED)
+                    return ret;
+            }
+            break;
+#endif /* WBXML_SUPPORT_OTA_SETTINGS */
+
         default:
             break;
@@ -2435,12 +2467,26 @@
 
 /**
- * @brief Encode a WBXML Opaque
+ * @brief Encode a WBXML Opaque, given a Buffer
  * @param encoder The WBXML Encoder
  * @param buff The Buffer to encode
  * @return WBXML_OK if encoding is OK, an error code otherwise
+ * @note This function is simple a wrapper to wbxml_encode_opaque_data()
+ */
+static WBXMLError wbxml_encode_opaque(WBXMLEncoder *encoder, WBXMLBuffer *buff)
+{
+    return wbxml_encode_opaque_data(encoder, wbxml_buffer_get_cstr(buff), wbxml_buffer_len(buff));
+}
+
+
+/**
+ * @brief Encode a WBXML Opaque
+ * @param encoder The WBXML Encoder
+ * @param data The data to encode
+ * @param data_len The data length to encode
+ * @return WBXML_OK if encoding is OK, an error code otherwise
  * @note  opaque = OPAQUE length *byte
  *        length = mb_u_int32
  */
-static WBXMLError wbxml_encode_opaque(WBXMLEncoder *encoder, WBXMLBuffer *buff)
+static WBXMLError wbxml_encode_opaque_data(WBXMLEncoder *encoder, WB_UTINY *data, WB_ULONG data_len)
 {
     /* Add WBXML_OPAQUE */
@@ -2449,9 +2495,9 @@
 
     /* Add Length */
-    if (!wbxml_buffer_append_mb_uint_32(encoder->output, wbxml_buffer_len(buff)))
+    if (!wbxml_buffer_append_mb_uint_32(encoder->output, data_len))
         return WBXML_ERROR_ENCODER_APPEND_DATA;
 
     /* Add Buffer */
-    if (!wbxml_buffer_append(encoder->output, buff))
+    if (!wbxml_buffer_append_data(encoder->output, data, data_len))
         return WBXML_ERROR_ENCODER_APPEND_DATA;
 
@@ -3152,4 +3198,85 @@
 
 
+#if defined( WBXML_SUPPORT_OTA_SETTINGS )
+
+/*******************
+ * OTA Settings
+ */
+
+/**
+ * @brief Encode a OTA ICON as opaque data 
+ * @param encoder The WBXML Encoder
+ * @param buffer The buffer to encode
+ * @return WBXML_OK if encoded, WBXML_NOT_ENCODED if not encoded, another error code otherwise 
+ * @note Nokia OTA Settings support for the ICON value in bookmarks.
+ *
+ * Nokia introduced a proprietary way of including icons in the old Nokia OTA Settings format when sending bookmarks.
+ * The encoding is done using base64 encoded images in XML, and encoding it as OPAQUE data in the WBXML. 
+ * The icon is embedded using an PARM element with name ICON.
+ *
+ * E.g. the following bookmark (XML) is valid:
+ * 
+ * <?xml version="1.0"?>
+ * <!DOCTYPE CHARACTERISTIC-LIST PUBLIC "-//WAPFORUM//DTD NOKIA-OTA 1.0//EN" "http://localhost:8080/OMABootSendWEB/DTD/characteristic_list.dtd">
+ * 
+ * <CHARACTERISTIC-LIST>
+ *    <CHARACTERISTIC TYPE="BOOKMARK"> 
+ *       <PARM NAME="NAME" VALUE="TV2"/>
+ *       <PARM NAME="URL" VALUE="http://wap.tv2.dk"/>
+ *       <PARM NAME="ICON" VALUE="R0lGODlhIAAgAPMAAP//AP8zAMwAAJkAAGYAAN0AAKoAAIgAAHcAAFUAAEQAACIAABEAALu7u8jIyP8AMyH5BAEAAA4ALAAAAAAgACAAQATh0MlJq704Z8bkucyiJARyHEM6HAjCNJw2hWNpnmdLJMrSyUBMICApAAqbhUiheDVgicQg8dPQSKaBQVAQGFaIXa8KDC2ZaCU5yL4QPe3yoXAIfDacfJVBZV9JNi16fWUiWChbAl5gBAxjMlclKFoGX4w8PkF/BJydO5hrbXp5caUYd6YycwVvqRY4R64goa4dMRKtGBxKaqNShIVMUSUcTwxTtCCGnC04LMWkkMtZlJbPMLdJNVlbXV8sYplW04iKi+Cg0tvUKixh6eqALfM64cnKwlH6PI+mu7y8sskaCMFFADs="/>
+ *    </CHARACTERISTIC>
+ * </CHARACTERISTIC-LIST>
+ *
+ * If not found, this is not encoded... and it will be encoded latter as an Inline String in wbxml_encode_value_element_buffer().
+ */
+static WBXMLError wbxml_encode_ota_nokia_icon(WBXMLEncoder *encoder, WB_UTINY *buffer)
+{
+    WBXMLError ret = WBXML_NOT_ENCODED;
+    
+    /* Is a VALUE attribute ? */
+    if ((encoder->current_tag != NULL) &&
+        (encoder->current_attr->wbxmlCodePage == 0x00) && 
+        (encoder->current_attr->wbxmlToken == 0x11) &&
+        (encoder->current_node && encoder->current_node->attrs)) 
+    {
+        WBXMLList *attrs = encoder->current_node->attrs;
+        WB_ULONG index = 0;
+        WB_ULONG nb_attrs = wbxml_list_len(attrs);
+        WB_BOOL found = FALSE;
+        
+        /* Search for a NAME="ICON" attribute */
+        while (!found && (index < nb_attrs)) {
+            WBXMLAttribute *attr = (WBXMLAttribute*)wbxml_list_get(attrs, index);
+            
+            if ((WBXML_STRCMP("NAME", wbxml_attribute_get_xml_name(attr)) == 0) &&
+                (WBXML_STRCMP("ICON", wbxml_attribute_get_xml_value(attr)) == 0))
+            {
+                WB_UTINY *data = NULL;
+                WB_LONG data_len = 0;
+                
+                /* Decode Base64 */
+                if ((data_len = wbxml_base64_decode(buffer, &data)) < 0)
+                    return WBXML_NOT_ENCODED;
+            
+                /* Encode opaque */
+                if ((ret = wbxml_encode_opaque_data(encoder, data, data_len)) != WBXML_OK)
+                    return ret;
+                
+                /* Free Data */
+                wbxml_free(data);
+                
+                found = TRUE;
+            }
+            
+            index++;
+        }
+    }
+    
+    return ret;
+}
+
+#endif /* WBXML_SUPPORT_OTA_SETTINGS */
+
+
 #if defined( WBXML_ENCODER_USE_STRTBL )
 
